# Global Seismic Activity Monitor

## Description

The Global Seismic Activity Monitor is a React-based web application that visualizes real-time and historical global earthquake data on an interactive 3D globe. It provides detailed statistics, insights into seismic events, and educational information about earthquake science. Users can explore recent and significant earthquakes, view their details, and understand their distribution and magnitude in a geographical context.

## Features

* **Interactive 3D Globe**: Visualize earthquake epicenters on a zoomable, rotatable globe.
* **Real-time & Historical Data**: Fetch and display earthquake data from USGS for various periods.
* **Geographical Layers**: Show tectonic plate boundaries and coastlines for geological context.
* **Latest Major Quake Highlight**: A pulsing ring and a timer highlight the most recent significant earthquake (M4.5+).
* **Detailed Earthquake View**: A modal displays comprehensive information for selected earthquakes, including a 2D regional map.
* **Smart Globe Rotation**: The globe auto-rotates and pauses on hover.
* **Dynamic Statistics & Charts**: View key statistics, summaries, and charts for different timeframes.
* **Earthquake Cluster Analysis**: Identify and view details for clusters of seismic events.
* **Featured Quakes**: See notable recent or historical earthquakes.
* **Educational Content**: Read brief explanations of earthquake concepts and a dedicated 'Learn' page.
* **Regional Faulting Display**: See regional fault lines for enhanced geological context.
* **Responsive Sidebar**: A sidebar dynamically loads and displays detailed analysis panels.

## Setup and Installation

To set up and run this project locally, follow these steps:

1.  **Clone the repository**:
    ```bash
    git clone https://github.com/builtbyvibes/global-seismic-activity-monitor.git
    ```
2.  **Navigate to the project directory**:
    ```bash
    cd global-seismic-activity-monitor
    ```
3.  **Install dependencies**:
    ```bash
    npm install
    ```
    (or `yarn install` if you use Yarn)

4.  **Run the development server**:
    ```bash
    npm run dev
    ```
    (or `yarn dev`)

5.  **Open your browser and navigate to the local URL provided by Vite (usually `http://localhost:5173` or similar).**

**Developing Cloudflare Workers:**

The serverless functions within the Cloudflare Worker (e.g., for the USGS proxy or API endpoints) can be developed and tested locally using the **Wrangler** CLI. While primary frontend development uses `npm run dev` (**Vite**), you can run a local development server for Worker functions to test them in isolation or develop new Worker-specific features.

*   Navigate to the project root (where `wrangler.toml` is located).
*   Use the command `npx wrangler dev` to start the local server for the Worker.
*   Refer to the [Cloudflare Wrangler documentation](https://developers.cloudflare.com/workers/wrangler/commands/#dev) for more details on local development and testing of **Workers**.

**Note on Local Development Approach:**
For most frontend development and testing, the **Vite** development server (`npm run dev`) is sufficient. It effectively proxies API requests to the appropriate Worker (either a deployed one or a local one if you're running both). Direct Worker development using `npx wrangler dev` becomes necessary when:
*   Implementing or debugging complex Worker-specific logic.
*   Initially setting up new Worker routes or functionalities.
*   Testing Worker behavior in complete isolation from the frontend.

## Technologies Used

* **React**: JavaScript library for building user interfaces.
* **React Globe GL**: For 3D globe visualization using ThreeJS/WebGL.
* **Tailwind CSS**: Utility-first CSS framework for styling.
* **Vite**: Frontend build tool.
* **JavaScript (ES6+)**
* **Cloudflare Workers**: For hosting, deployment, and serverless backend functions.

## Deployment / Infrastructure

The application is deployed as a **Cloudflare Worker**, which handles both the serving of the static frontend assets (built with **Vite**) and the backend serverless functions.

*   **Unified Deployment**: The React-based user interface and the serverless backend logic (e.g., USGS proxy, API endpoints) are managed and deployed as a single Cloudflare Worker.
*   **Static Asset Serving**: The Worker script is configured to serve the static files (HTML, CSS, JavaScript, images) generated by the Vite build process. This is typically managed via an `ASSETS` binding in the `wrangler.toml` configuration.
*   **Serverless Functions**: API endpoints, data proxying, and other backend tasks are handled by the same Worker script.
*   **Configuration**: Worker configuration, including routes, environment variables, KV/D1 bindings, and build steps for the worker itself, is managed through the `wrangler.toml` file.
*   **Benefits**: This setup offers significant advantages, including:
    *   **Scalability**: **Cloudflare Workers** scale automatically to handle traffic load.
    *   **Performance**: Cloudflare's extensive Content Delivery Network (CDN) ensures that the application and its data are delivered quickly to users worldwide.
    *   **Cost-Effectiveness**: A unified **Worker-based** architecture can be highly cost-effective.
    *   **Simplified DevOps**: CI/CD for the entire application (frontend and backend) is streamlined by deploying to **Cloudflare Workers**.

## Environments and Deployment

This project uses different environments for development and deployment, all managed through Cloudflare Workers and Wrangler.

*   **`production`**: The live environment for end-users.
*   **`staging`**: For pre-production testing, using the same database as production.
*   **`preview`**: Automatically generated for each commit on a non-production branch, using its own data.
*   **`dev`**: The local development environment, using Vite for the frontend and Wrangler for the worker.

Deployments are typically automated. For instance, merging to the main branch deploys to production. Manual deployments can be done using `npm run deploy:staging` or `npm run deploy:production`.

## Project Structure

The project is organized into the following main directories:

-   **`functions/`**: Serverless function logic for the Cloudflare Worker, including API handlers, background processing, and routing.
-   **`src/`**: Core source code for the React application.
    -   **`assets/`**: Static assets like images and JSON data files.
    -   **`components/`**: Reusable UI components.
    -   **`constants/`**: Application-wide constants.
    -   **`contexts/`**: React Context providers for global state management.
    -   **`hooks/`**: Custom React hooks.
    -   **`pages/`**: Top-level components for different application pages.
    -   **`services/`**: Modules for interacting with external APIs.
    -   **`utils/`**: Utility functions.
-   **`migrations/`**: Database migration files for the D1 database.
-   **`docs/`**: Generated documentation.
-   **`.github/`**: GitHub Actions workflows for CI/CD.
-   **`public/`**: Publicly accessible files.
-   **`scripts/`**: Scripts for benchmarking and other tasks.

The `wrangler.toml` file at the root contains the configuration for the Cloudflare Workers project.

## Technical Documentation

The codebase includes comprehensive JSDoc comments that explain components, functions, and data structures.

To generate HTML documentation from these comments, run the following command:

```bash
npm run docs
```

This will create the documentation in the `docs/jsdoc/` directory. Open the `index.html` file in that directory to view the documentation.

## Development Journey & Concept: "Vibe-Coding" with Gemini Canvas

This project was developed using an AI-assisted, iterative process called "vibe-coding," with Gemini Canvas as a key tool. This exploratory approach allowed for rapid prototyping and refinement, with AI assisting in code generation, debugging, and documentation. The project serves as a testbed for advanced LLM capabilities in software engineering, with AI agents driving ongoing development and enhancements. This collaborative and experimental process, which also utilizes tools like the Claude code CLI, highlights the potential of AI to augment the creative and technical aspects of software development.

The project reflects the spirit of innovation and agile creation championed by **Built By Vibes**.

* **Twitter**: [@builtbyvibes](https://twitter.com/builtbyvibes)
* **Website**: [www.builtbyvibes.com](https://www.builtbyvibes.com)

## Project Status

This project is under active development to enhance performance, data richness, and analytical capabilities. Key areas of focus include:

*   **Performance Optimization:** Critical bottlenecks in the earthquake clustering algorithm (O(NÂ²) complexity) and sitemap generation are being addressed. The plan includes implementing spatial indexing and optimizing database queries to significantly improve performance.
*   **Historical Data Integration:** A robust batch processing system is being developed to ingest and analyze historical earthquake data from USGS archives. This will enable richer historical analysis and a more comprehensive dataset.
*   **Enhanced Regional Analysis:** New features are being built to provide more detailed regional seismic analysis, including the integration of regional fault data and dedicated regional views.
*   **Educational Enhancements:** The project is expanding its educational content with interactive learning modules and better correlation between seismic events and known faults.

The development roadmap is managed through a detailed task list, prioritizing critical performance fixes, followed by historical data integration and advanced feature enhancements.

## Development Roadmap

The development of the Global Seismic Activity Monitor is prioritized to deliver the most critical improvements first. The roadmap is divided into the following phases:

1.  **Critical Performance Fixes:** The immediate focus is on optimizing the core algorithms for clustering and data processing to ensure the application is fast and responsive, even with large datasets.
2.  **Historical Data Foundation:** Once performance is optimized, the next priority is to build the infrastructure for ingesting and processing historical earthquake data, which will form the foundation for richer analysis.
3.  **Advanced Features:** With a performant and data-rich platform, the focus will shift to developing advanced features for regional analysis, educational content, and fault integration.
4.  **Enhancement and Polish:** The final phase will involve refining the user experience, improving the API, and adding other advanced features.

## Data Source

* Earthquake data is sourced from the **U.S. Geological Survey (USGS) Earthquake Hazards Program** via their GeoJSON feeds.