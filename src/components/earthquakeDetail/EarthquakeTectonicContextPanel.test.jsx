import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';

import EarthquakeTectonicContextPanel from './EarthquakeTectonicContextPanel';
// Mock the utility functions from detailViewUtils and the assets
// We are primarily testing the panel's logic to process and display this data.

// Mock findClosestBoundary (which is internal to the component)
// We'll achieve this by mocking the module that contains it if it were external,
// but since it's internal, we rely on passing props that make it behave predictably OR
// we test its output (the text generated by generateTectonicContextText) by controlling its inputs.
// For this test, generateTectonicContextText IS internal. So we test its effects.
// The most direct way to test generateTectonicContextText's different outputs is to
// provide different mock results for `closestBoundaryInfo` which would normally be returned by `findClosestBoundary`.
// So, we'll mock `findClosestBoundary` effectively by controlling the inputs to `generateTectonicContextText` via `detailData`.

// Mock tectonicBoundariesData - returning a minimal features array for map rendering tests
jest.mock('../../assets/TectonicPlateBoundaries.json', () => ({
  type: "FeatureCollection",
  features: [
    {
      type: "Feature",
      properties: { Boundary_Type: "Convergent", PlateA: "A", PlateB: "B" },
      geometry: { type: "LineString", coordinates: [[0,0], [1,1]] } // Minimal valid LineString
    }
  ]
}));

// getFaultType is imported by the component. Its own unit tests are trusted.

describe('EarthquakeTectonicContextPanel', () => {
  const mockDetailDataBase = {
    geometry: { coordinates: [10, 20, 5] }, // lon, lat, depth
    properties: {
      products: {
        origin: [{ properties: { rake: -90 } }] // Normal fault
      }
    }
  };
  const mockPropertiesBase = {
    place: "Test Location, CA",
  };

  const defaultProps = {
    detailData: mockDetailDataBase,
    properties: mockPropertiesBase,
    exhibitPanelClass: 'test-panel',
    exhibitTitleClass: 'test-title',
  };

  // Helper to create props with specific closest boundary mock results for text generation
  // This works because findClosestBoundary is deterministic based on lat/lon and boundary data.
  // For more direct mocking of findClosestBoundary if it were imported:
  // jest.mock('./path-to-findClosestBoundary-if-it-was-external', () => ({
  //   findClosestBoundary: jest.fn()
  // }));
  // And then in test: findClosestBoundary.mockReturnValueOnce(...);

  test('renders correctly with valid props', () => {
    render(<EarthquakeTectonicContextPanel {...defaultProps} />);
    expect(screen.getByText('Tectonic Context')).toBeInTheDocument();
    expect(screen.getByText(/Location: Test Location, CA/i)).toBeInTheDocument();
    expect(screen.getByText(/Coordinates: 20.00°N, 10.00°E/i)).toBeInTheDocument();
    expect(screen.getByText(/Fault Type: Normal Fault/i)).toBeInTheDocument();
  });

  test('renders SVG map, earthquake marker, and legend', () => {
    render(<EarthquakeTectonicContextPanel {...defaultProps} />);
    const svgMap = screen.getByRole('graphics-document', { hidden: true }); // SVGs might not have explicit roles
    expect(svgMap).toBeInTheDocument();
    expect(svgMap.querySelector('circle[fill="gold"]')).toBeInTheDocument(); // Earthquake marker
    expect(screen.getByText('★ Event')).toBeInTheDocument();
    expect(screen.getByText('Convergent')).toBeInTheDocument(); // Legend item (from mock asset)
  });

  describe('Tectonic Context Text Generation', () => {
    // To test different text outputs, we'd ideally mock findClosestBoundary.
    // Since it's internal, we can test it by providing different earthquake locations
    // that would result in different `closestBoundaryInfo` relative to our *actual* (mocked) boundariesData.
    // Or, if `generateTectonicContextText` were exported, we'd test it directly.
    // Given the setup, we test the panel's output which *uses* these internal functions.

    test('renders text for Normal fault near a (mocked) Convergent boundary', () => {
      // Our mocked tectonicBoundariesData has a Convergent boundary at [[0,0], [1,1]]
      // Let's place the earthquake very close to it.
      const props = {
        ...defaultProps,
        detailData: {
          ...mockDetailDataBase,
          geometry: { coordinates: [0.1, 0.1, 5] }, // lon, lat, depth (very close to [0,0])
          properties: { products: { origin: [{ properties: { rake: -90 } }] } } // Normal
        }
      };
      render(<EarthquakeTectonicContextPanel {...props} />);
      expect(screen.getByText(/This normal fault occurred approximately \d+ km from a convergent plate boundary\./i)).toBeInTheDocument();
      // The specific text for "Normal at Convergent"
      expect(screen.getByText(/normal faulting can sometimes occur due to stresses from the bending of the subducting plate/i)).toBeInTheDocument();
    });

    test('renders text for Reverse fault near a (mocked) Convergent boundary', () => {
      const props = {
        ...defaultProps,
        detailData: {
          ...mockDetailDataBase,
          geometry: { coordinates: [0.1, 0.1, 5] },
          properties: { products: { origin: [{ properties: { rake: 90 } }] } } // Reverse
        }
      };
      render(<EarthquakeTectonicContextPanel {...props} />);
      expect(screen.getByText(/This reverse\/thrust fault occurred approximately \d+ km from a convergent plate boundary\./i)).toBeInTheDocument();
      expect(screen.getByText(/Reverse faulting, like this event, is common at convergent boundaries/i)).toBeInTheDocument();
    });

    test('renders text for intraplate earthquake if far from boundaries', () => {
      const props = {
        ...defaultProps,
        detailData: {
          ...mockDetailDataBase,
          geometry: { coordinates: [100, 80, 5] }, // Far from boundary at [0,0]
          properties: { products: { origin: [{ properties: { rake: -90 } }] } } // Normal
        }
      };
      render(<EarthquakeTectonicContextPanel {...props} />);
      expect(screen.getByText(/This normal fault appears to be an intraplate event/i)).toBeInTheDocument();
      expect(screen.getByText(/occurring away from major plate boundaries \(closest boundary found > \d+ km\)/i)).toBeInTheDocument();
    });
  });

  describe('Conditional Rendering / Error Handling', () => {
    test('displays message if detailData is missing', () => {
      render(<EarthquakeTectonicContextPanel {...defaultProps} detailData={null} />);
      expect(screen.getByText('Earthquake location data is not available.')).toBeInTheDocument();
    });

    test('displays message if detailData.geometry is missing', () => {
      render(<EarthquakeTectonicContextPanel {...defaultProps} detailData={{ properties: {} }} />);
      expect(screen.getByText('Earthquake location data is not available.')).toBeInTheDocument();
    });

    test('handles missing rake gracefully (shows Unknown Fault Type)', () => {
      const propsNoRake = {
        ...defaultProps,
        detailData: {
          ...mockDetailDataBase,
          properties: { products: { origin: [{ properties: { rake: undefined } }] } }
        }
      };
      render(<EarthquakeTectonicContextPanel {...propsNoRake} />);
      expect(screen.getByText(/Fault Type: Unknown Fault Type/i)).toBeInTheDocument();
      // Also check the generated tectonic text for "unknown fault type"
      expect(screen.getByText(/This unknown fault type occurred approximately \d+ km from a convergent plate boundary\./i)).toBeInTheDocument();
    });
  });

  test('matches snapshot with typical valid props', () => {
    const { container } = render(<EarthquakeTectonicContextPanel {...defaultProps} />);
    expect(container).toMatchSnapshot();
  });
});
