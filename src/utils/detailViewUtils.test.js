import { describe, it, expect, vi } from 'vitest';
import { getBeachballPathsAndType } from './detailViewUtils';
import { isValidNumber } from './utils';

// Mock the isValidNumber function from the actual utils.js
vi.mock('./utils', () => ({
  isValidNumber: vi.fn(),
}));

const R = 50; // Radius used in the source file
const C = 60; // Center coordinate used in the source file

// Expected path structures for different fault types
const STRIKE_SLIP_LIKE_PATHS = {
  shadedPaths: [
    `M${C},${C-R} A${R},${R} 0 0 1 ${C+R},${C} L${C},${C} Z`,
    `M${C},${C+R} A${R},${R} 0 0 1 ${C-R},${C} L${C},${C} Z`
  ],
  nodalPlanes: [
    { type: 'line', x1: C, y1: C - R, x2: C, y2: C + R },
    { type: 'line', x1: C - R, y1: C, x2: C + R, y2: C }
  ],
  faultType: 'STRIKE_SLIP_LIKE' // The function groups some types under this
};

const NORMAL_PATHS = {
  shadedPaths: [
    `M${C},${C-R} C ${C-R*1.5},${C-R*0.5}, ${C-R*1.5},${C+R*0.5}, ${C},${C+R} C ${C-R*0.5},${C+R*0.5}, ${C-R*0.5},${C-R*0.5}, ${C},${C-R} Z`,
    `M${C},${C-R} C ${C+R*1.5},${C-R*0.5}, ${C+R*1.5},${C+R*0.5}, ${C},${C+R} C ${C+R*0.5},${C+R*0.5}, ${C+R*0.5},${C-R*0.5}, ${C},${C-R} Z`
  ],
  nodalPlanes: [
    { type: 'path', d: `M${C-R*0.8},${C-R*0.6} Q${C},${C} ${C-R*0.8},${C+R*0.6}` },
    { type: 'path', d: `M${C+R*0.8},${C-R*0.6} Q${C},${C} ${C+R*0.8},${C+R*0.6}` }
  ],
  faultType: 'NORMAL'
};

const REVERSE_PATHS = {
  shadedPaths: [
    `M${C-R},${C} C ${C-R*0.5},${C-R*1.5}, ${C+R*0.5},${C-R*1.5}, ${C+R},${C} C ${C+R*0.5},${C-R*0.5}, ${C-R*0.5},${C-R*0.5}, ${C-R},${C} Z`,
    `M${C-R},${C} C ${C-R*0.5},${C+R*1.5}, ${C+R*0.5},${C+R*1.5}, ${C+R},${C} C ${C+R*0.5},${C+R*0.5}, ${C-R*0.5},${C+R*0.5}, ${C-R},${C} Z`
  ],
  nodalPlanes: [
    { type: 'path', d: `M${C-R*0.6},${C-R*0.8} Q${C},${C} ${C+R*0.6},${C-R*0.8}` },
    { type: 'path', d: `M${C-R*0.6},${C+R*0.8} Q${C},${C} ${C+R*0.6},${C+R*0.8}` }
  ],
  faultType: 'REVERSE'
};

// Paths generated by the default case in the switch statement
const DEFAULT_SWITCH_CASE_PATHS = {
  shadedPaths: [
    `M${C-R},${C} A${R},${R} 0 0 1 ${C},${C-R} L${C},${C} Z`,
    `M${C+R},${C} A${R},${R} 0 0 1 ${C},${C+R} L${C},${C} Z`
  ],
  nodalPlanes: [
    { type: 'line', x1: C, y1: C - R, x2: C, y2: C + R },
    { type: 'line', x1: C - R, y1: C, x2: C + R, y2: C }
  ],
  faultType: 'STRIKE_SLIP_LIKE' // Default case in switch sets this faultType
};


describe('getBeachballPathsAndType', () => {
  beforeEach(() => {
    // Reset mocks before each test
    isValidNumber.mockReset();
  });

  it('should return empty paths and UNKNOWN type for invalid rake input', () => {
    isValidNumber.mockReturnValue(false);
    const result = getBeachballPathsAndType('not a number');
    expect(isValidNumber).toHaveBeenCalledWith(NaN); // parseFloat('not a number') is NaN
    expect(result).toEqual({ shadedPaths: [], faultType: 'UNKNOWN', nodalPlanes: [] });
  });

  it('should return empty paths and UNKNOWN type for undefined rake input', () => {
    isValidNumber.mockReturnValue(false); // parseFloat(undefined) is NaN
    const result = getBeachballPathsAndType(undefined);
    expect(isValidNumber).toHaveBeenCalledWith(NaN);
    expect(result).toEqual({ shadedPaths: [], faultType: 'UNKNOWN', nodalPlanes: [] });
  });

  it('should return empty paths and UNKNOWN type for null rake input', () => {
    // parseFloat(null) is NaN in some environments or 0. Let's assume parseFloat(null) -> 0, then isValidNumber(0) is true.
    // However, if isValidNumber is correctly mocked to return false for non-numeric strings,
    // and if null is passed as a string 'null', then it would be NaN.
    // The original code does parseFloat(rake). If rake is null (object), parseFloat(null) is NaN.
    isValidNumber.mockReturnValue(false);
    const result = getBeachballPathsAndType(null);
    expect(isValidNumber).toHaveBeenCalledWith(NaN); // parseFloat(null) results in NaN
    expect(result).toEqual({ shadedPaths: [], faultType: 'UNKNOWN', nodalPlanes: [] });
  });

  // Test cases for each fault type based on rake values
  const testCases = [
    // STRIKE_SLIP
    { rake: 0, expected: STRIKE_SLIP_LIKE_PATHS },
    { rake: 22.5, expected: STRIKE_SLIP_LIKE_PATHS },
    { rake: -22.5, expected: STRIKE_SLIP_LIKE_PATHS },
    { rake: 157.6, expected: STRIKE_SLIP_LIKE_PATHS },   // > 157.5
    { rake: -157.6, expected: STRIKE_SLIP_LIKE_PATHS }, // < -157.5
    { rake: 180, expected: STRIKE_SLIP_LIKE_PATHS },
    { rake: -180, expected: STRIKE_SLIP_LIKE_PATHS },

    // REVERSE
    { rake: 67.5, expected: REVERSE_PATHS },
    { rake: 90, expected: REVERSE_PATHS },
    { rake: 112.5, expected: REVERSE_PATHS },

    // NORMAL
    { rake: -67.5, expected: NORMAL_PATHS },
    { rake: -90, expected: NORMAL_PATHS },
    { rake: -112.5, expected: NORMAL_PATHS },

    // OBLIQUE_REVERSE (maps to STRIKE_SLIP_LIKE paths)
    { rake: 22.6, expected: STRIKE_SLIP_LIKE_PATHS }, // > 22.5
    { rake: 45, expected: STRIKE_SLIP_LIKE_PATHS },
    { rake: 67.4, expected: STRIKE_SLIP_LIKE_PATHS }, // < 67.5
    { rake: 112.6, expected: STRIKE_SLIP_LIKE_PATHS }, // > 112.5
    { rake: 135, expected: STRIKE_SLIP_LIKE_PATHS },
    { rake: 157.5, expected: DEFAULT_SWITCH_CASE_PATHS }, // Hits default switch

    // OBLIQUE_NORMAL (maps to STRIKE_SLIP_LIKE paths)
    { rake: -22.6, expected: STRIKE_SLIP_LIKE_PATHS }, // < -22.5
    { rake: -45, expected: STRIKE_SLIP_LIKE_PATHS },
    { rake: -67.4, expected: STRIKE_SLIP_LIKE_PATHS }, // > -67.5
    { rake: -112.6, expected: STRIKE_SLIP_LIKE_PATHS }, // < -112.5
    { rake: -135, expected: STRIKE_SLIP_LIKE_PATHS },
    { rake: -157.5, expected: DEFAULT_SWITCH_CASE_PATHS }, // Hits default switch

    // Unknown case (should use default in switch, which is STRIKE_SLIP_LIKE)
    // This case is technically hard to hit if isValidNumber is true, as all numbers fall into one of the defined rake ranges.
    // The original code's default switch case seems to be a fallback,
    // but the initial faultType='UNKNOWN' and subsequent conditions cover all valid number ranges.
    // If parseFloat results in a number not caught by any condition (which shouldn't happen for finite numbers),
    // faultType would remain 'UNKNOWN', leading to the default switch case.
    // Let's simulate isValidNumber returning true but faultType somehow not matching.
    // This test is more for switch's default branch coverage if conditions were different.
    // For now, any valid number will fall into a category that assigns a specific faultType before the switch.
  ];

  testCases.forEach(({ rake, expected }) => {
    it(`should return type ${expected.faultType} for rake ${rake}`, () => {
      isValidNumber.mockReturnValue(true); // Assume rake is a valid number for these tests
      const result = getBeachballPathsAndType(rake);
      expect(isValidNumber).toHaveBeenCalledWith(parseFloat(rake));
      // Compare each field separately for clarity if there's a mismatch
      expect(result.faultType).toBe(expected.faultType);
      expect(result.shadedPaths).toEqual(expected.shadedPaths);
      expect(result.nodalPlanes).toEqual(expected.nodalPlanes);
    });
  });

  it('should handle string number inputs correctly', () => {
    isValidNumber.mockReturnValue(true);
    const result = getBeachballPathsAndType("45"); // OBLIQUE_REVERSE -> STRIKE_SLIP_LIKE
    expect(isValidNumber).toHaveBeenCalledWith(45);
    expect(result.faultType).toBe(STRIKE_SLIP_LIKE_PATHS.faultType);
    expect(result.shadedPaths).toEqual(STRIKE_SLIP_LIKE_PATHS.shadedPaths);
  });

  // Test the default case of the switch statement directly is tricky as all valid numbers are categorized.
  // The initial `faultType = 'UNKNOWN'` would hit the default if no other conditions are met.
  // However, with `isValidNumber(r)` being true, one of the rake conditions will always be met.
  // The only way `faultType` remains 'UNKNOWN' before switch is if `isValidNumber` is false,
  // which is tested by the first few tests.
  // The `default` in the switch is more of a safeguard.
  // We can ensure the paths for the 'UNKNOWN' initial state (if it were to reach the switch) are as expected.
  // This is effectively tested if `isValidNumber` is false, as it returns UNKNOWN and empty paths *before* the switch.
  // The default case in the switch actually produces STRIKE_SLIP_LIKE paths, not empty ones.
  // This path is taken if `faultType` is something not explicitly handled by other cases.
  // Given the current logic, this specific default branch in the switch is unreachable
  // if `isValidNumber` is true, because all numeric rakes get classified.
  // If `isValidNumber` is false, the function returns early.
});
